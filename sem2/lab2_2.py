import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

fd = 1024  # частота дискретизации
f = 8  # частота сигнала
ph = 0  # фаза
A = 1  # амплитуда
N = int(fd / f)  # число точек на периоде 128
t = np.arange(N)  # временной интервал
y = A * signal.square(2 * np.pi * t / N + ph, duty=0.25)  # прямоугольный импульс, скважность 0.25
CS = np.fft.fft(y)  # частотный спектр сигнала
CS2 = CS.copy()  # второй частотный спектр
AS = np.abs(CS)  # амплитудный спектр
Et = np.linalg.norm(y)**2  # энергия t
Ew = np.linalg.norm(AS)**2 / N  # энергия w
k = 0
while (Ew > 0.95 * Et):  # продолжаем пока энергия больше 121.6
    CS2[int(N/2) - k] = 0  # зануляем гармоники слева относ. центра (64)
    CS2[int(N/2) + 1 + k] = 0  # зануляем гармоники справа относ. центра (64)
    Ew = np.linalg.norm(np.abs(CS2))**2 / N  # новое значение энергии после зануления
    k += 1
gr = int(N/2) - k
print('Кол-во оставленных гармоник с начала спектра: ', gr)
fig, axs = plt.subplots(2, 2)
fig.suptitle('графики')
axs[0, 0].plot(t/fd, y)  # исходный график
axs[0, 0].set_title('исходный сигнал')
axs[0, 1].stem(t/fd, AS)  # график исходного амплитудного спектра
axs[0, 1].set_title('исходный амплитудный спектр')
y2 = np.fft.ifft(CS2).real  # обратное преобразование Фурье (восстановленный сигнал)
axs[1, 0].plot(t/fd, y2)  # восстановленный сигнал
axs[1, 0].set_title('восстановленный сигнал')
AS2 = np.abs(CS2)  # новый амплитудный спектр
axs[1, 1].stem(t/fd, AS2)  # график нового амплитудного спектра
axs[1, 1].set_title('новый амплитудный спектр')
plt.show()